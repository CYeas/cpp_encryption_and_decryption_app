密钥生成[编辑]
首先要使用概率算法来验证随机产生的大的整数是否质数，这样的算法比较快而且可以消除掉大多数非质数。假如有一个数通过了这个测试的话，那么要使用一个精确的测试来保证它的确是一个质数。
除此之外这样找到的 {\displaystyle p} p和 {\displaystyle q} q还要满足一定的要求，首先它们不能太靠近，此外 {\displaystyle p-1} p-1或 {\displaystyle q-1} q-1的因子不能太小，否则的话 {\displaystyle N} N也可以被很快地分解。
此外寻找质数的算法不能给攻击者任何信息，这些质数是怎样找到的，尤其产生随机数的软件必须非常好。要求是随机和不可预测。这两个要求并不相同。一个随机过程可能可以产生一个不相关的数的系列，但假如有人能够预测出（或部分地预测出）这个系列的话，那么它就已经不可靠了。比如有一些非常好的随机数算法，但它们都已经被发表，因此它们不能被使用，因为假如一个攻击者可以猜出 {\displaystyle p} p和 {\displaystyle q} q一半的位的话，那么他们就已经可以轻而易举地推算出另一半。
此外密钥 {\displaystyle d} d必须足够大，1990年有人证明假如 {\displaystyle p} p大于 {\displaystyle q} q而小于 {\displaystyle 2q} 2q(这是一个很经常的情况）而 {\displaystyle d<{\frac {1}{3}}\times N^{\frac {1}{4}}} d<\frac{1}{3} \times N^{\frac{1}{4}}，那么从 {\displaystyle N} N和 {\displaystyle e} e可以很有效地推算出 {\displaystyle d} d。此外 {\displaystyle e=2} e=2永远不应该被使用。
速度[编辑]
比起DES和其它对称算法来说，RSA要慢得多。实际上Bob一般使用一种对称算法来加密他的信息，然后用RSA来加密他的比较短的对称密码，然后将用RSA加密的对称密码和用对称算法加密的消息送给Alice。
密钥分配[编辑]
和其它加密过程一样，对RSA来说分配公钥的过程是非常重要的。分配公钥的过程必须能够抵挡中间人攻击。假设Eve交给Bob一个公钥，并使Bob相信这是Alice的公钥，并且她可以截下Alice和Bob之间的信息传递，那么她可以将她自己的公钥传给Bob，Bob以为这是Alice的公钥。Eve可以将所有Bob传递给Alice的消息截下来，将这个消息用她自己的密钥解密，读这个消息，然后将这个消息再用Alice的公钥加密后传给Alice。理论上Alice和Bob都不会发现Eve在偷听他们的消息。今天人们一般用可靠的第三方机构签发证书来防止这样的攻击。
时间攻击[编辑]
1995年有人提出了一种非常意想不到的攻击方式：假如Eve对Alice的硬件有充分的了解，而且知道它对一些特定的消息加密时所需要的时间的话，那么她可以很快地推导出d。这种攻击方式之所以会成立，主要是因为在进行加密时所进行的模指数运算是一个比特一个比特进行的，而比特为1所花的运算比比特为0的运算要多很多，因此若能得到多组消息与其加密时间，就会有机会可以反推出私钥的内容。